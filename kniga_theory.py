import os
import csv


def f(x):
    return x + 3


z = f(2)

if z == 5:
    print("z равно 5")
else:
    print("z не равно 5")


# без ввода параметров
def z():
    return 59 + 10


print(z())


# Принимает больше одного параметра

def sisi(a, b, c, d):
    return a + b + (c * d)


k = 2
v = 5
n = 8
m = 4

print(sisi(v, n, k, m))


# наконец функция не обязана содержать инструкцию return. Если функиции нчего возращать она выводит None

def g():
    f = 1 + 1


print(g())

print(len("Монти") + len("Пайтон"))  # функия len() выводит длину объекта например в строке  5 + 6 = 11
print(int(31.3))


# Многократное использование функций

def even_odd(x):
    if x % 2 != 0:
        print("Нечетное")
    else:
        print("четное")


even_odd(3)
even_odd(4)


# Благодоря этому методу можно сократить код написав функцию один раз, и в далбнейшем использовать ее
# когда снова понадобится узнать четное или не четное число в программе


def my_x_y(x, y=6):
    return x * y


# Обязательные и необязательные параметры. В данном примере x обязательный , а (y) нет, т.к (y=6)
print(my_x_y(6, 3))

# При вводе global функция в функции my_x берется переменная в глобальной видимости а не в локальной
x = 16


def my_x():
    global x
    x *= 2
    print(x)


my_x()

# Обработка исключений
# Если ваш код может сгенерировать ошибку то тогда использойте составную инструкцию :
# try:
# except ZeroDivisionError:
# a = input("Введите первое число: ")
# b = input("Введите второе число: ")
# a = str(a)
# b = str(b)
# try:
#
#     a // b
# except (ZeroDivisionError, ValueError, TypeError):
#     print("Поймано исключение")

# метод split()
# Используется для разделениея одной строки на и более
print("Я сегодня проснулся в 10.После чего оделся и сел за компьютер".split("."))

# Метод join()
# Позволяет добаввлять новыые символы между всеми символами в строке
first_one = "1234"
result = "+".join(first_one)  # В ковычки можно написать что угодно
print(result)

# Можно превратить список строк в единную строку вызвам join()
jopa = ["я",
        "сегодня",
        "ел",
        "только",
        "омлет",
        "на",
        "завтрак"]
one = " ".join(jopa)
print(one)

# Метод strip() используется для удаления пробельных символов в начале и в конце

s = "     Vagina    "
s = s.strip()
print(s)

# Метод replace() заменяет каждое вхождение строки другой строкой
# Первый парамет который нужно изменить ,второй которой нужно изменить
euq = "Все животные одинакковые"
print(euq)
print(euq.replace("Все", "Вы"))

# Поискк индекса
print("животные".index("н"))

# Ключевое слово in
# Ключевое слово in проверяет ,содеожится ли строка в другой строке
# И возращает True или False

print("Кот" in "Кот в мешке")

print("Мышь" in "Кот в мешке")

# Помсетите ключевое слово not перед in , чтобы проверить отсутствие строки в другой строке

print("Потер" not in "Гарри")
print("Потер" not in "Гарри Потер")

"""----------------ЦИКЛЫ--------------"""
"""================Цикл for=============="""
"""Цикл for определяется синтаксисом for имя_переменной in имя_итерируемого_объекта: инструкции , где имя_переменной - 
выбранное вами имя переменной, ккоторая назначается значению каждого элемента в итерируемом объекте,
 а инструкции - код,который выпоняется при каждом прохождении цикла.
 Ниже пример перебора символов строки 
"""

name = "Ted"
for you in name:
    print(you)

"""При помощи цикла for можно изменять элементы в изменяемом итерукмом объекте, например в списке"""

# tw = ["Во все тяжккиие",
#       "Секретные материалы",
#       "Фарго"]
# i = 0
# for show in tw:
#     new = tw[i]
#     new = new.upper()
#     tw[i] = new
#     i += 1

# print(tw)

"""Пример использования цикла for  для итеририрования элементов кортежа"""

coms = ("Теория большого взрыва",
        "Друзья",
        "Папины дочки")

for show in coms:
    print(show)

"""Пример использования цикла for для перебора ключей в словаре"""

people = {"Джим Парсонс":
              "Теория большого взрыва",
          "Брайан Крэнстон":
              "Во все тяжкие",
          "Вин Дросель":
              "Форсаж"
          }

for character in people:
    print(character)

auto = {"BMW": ("e30", "e36", "m5"),
        "Nissan": ("350Z", "240SX", "Silvia"),
        "Mazda": ("RX-7", "mx-5"),
        "Toyota": ("Supra", "AE-86")}

for i, cars in enumerate(auto):
    car = auto
    car = car.values()

print(car)

"""Посколькку получение доступа кк каждому элементу в итеруемом объекте и его индексу - распростроненная задача , у 
Paython для этого есть специальный синтаксис"""

"""for i, show in enumerate(ОБЪЕКТ)"""

tw = ["Во все тяжкие",
      "Секретные материиалы",
      "Фарго"]

for i, show in enumerate(tw):
    new = tw[i]
    new = new.upper()
    tw[i] = new

print(tw)
# Вместо перебора списка tw вы передали список tw в enumerate и выполнили перебор результата, что позволило
# ввести новую переменную i , отслеживающую текущий индекс


"""Циклы for можно использовать для перемещения данных между изменяемыми итерируемыми объекктами.Например, вы можете 
использовать два циккла for, чтобы взять все строки из двух разных списков, сделать прописными все символы в  этих
строках и поместить измененные строки в новый список"""

tv = ["Во все тяжкие",
      "Секретные материалы",
      "Фарго"]

cams = ["Теория большого взрыва",
        "Друзья",

        "Папины дочки"]

all_shows = []
for show in tv:
    show = show.upper()
    all_shows.append(show)

for show in cams:
    show = show.upper()
    all_shows.append(show)

print(all_shows)

print("\n")

"""Циклы while.
Цикл выполняет код до тех пор, пока выражение принимает истинно(True).Ситаксис цикла while слующий:
while выражение: код_для_выполнения.Выражение определяет ,будет цикл продолжаться или нет, а код_для_выполнения
должен выполняться циклом"""

x = 10
while x > 0:
    print(f"{x}")
    x -= 1
print("С новым годом!")

print("\n")
# Ваш цикл выполняет свой код пока выражение является истиннл(True).x = 10 , x > 0 True.
# Цикл выводит значение x , затем уменьшает x  на 1.Теперь x = 9, x > 0 True , и т.д.
# Этот процесс продалжается пока x  не уменьшится до 0, здесь выражение x > 0  примет значение False, и тогда ваш цикл
# завершится


"""Инструкция break.
Вы можете использовать инструкцию break - инструкция с ключевым словом break, - чтобы прекратить цикл.Следующий цикл 
выполнится сто раз."""

for i in range(0, 100):
    print(i)

print("\n")
# Если вы добавите инструкцию break, цикл выполниится лишь один раз.

for i in range(0, 100):
    print(i)
    break

print("\n")
# Как только Python сталкивается с инструкцией break, цикл завершается.Вы можете использовать цикл while  и ключевое
# слово break для написанния программы, которая будет просить пользователя ввести данные, пока он не введет букву X ,
# чтобы выйти

qs = ["Как тебя зовут?",
      "Твой любимый цвет?",
      "Что ты делаешь?"]
# n = 0
# while True:
#     print("Ввести X для выхода")
#     a = input(qs[n])
#     if a == "X":
#         break
#     n =(n + 1) % 3

# При каждом прохождении цикла ваша программа задает пользователю один из вопросов из списка qs.
# n - переменная индекса.При каждом прохождении цикла вы присваиваете n  значение выражения (n + 1) % 3, что позволяет
# бесконечно проходить по каждому вопросу в списек qs.При первом прохождении цикла n начинает с 0.Затем n присваивается
# значение выражениия (0 + 1) % 3 , которое равно 1.После чего n  присваивается значение (1 + 1) % 3, которое равно 2,
# ведь всегда, когда первое число в выражении с операторм деления по модулю меньше второго,ответом является это первое
# число.Наконец n  присваивается значение (2 + 1) % 3, равное 0, как и в начале.

"""Инструкция contiune"""

# Вы можете использовать инструкцию continue, чтобы прервать текущую итерацию цикла и проложитть, со следующей итерации.
# Скажем, вам нужно выывести все числа от 1 до 5 , кроме числа 3. Вы можете это осуществить ,используя цикл for и
# инструкцию continue

for i in range(1, 6):
    if i == 3:
        continue
    print(i)

print("\n")

# В этом цикле, когда переменная i  принимает значение 3, выполняется инструкция continue - тогда вместо того, чтобы
# полностью завершится, как в случае с ключевым словом  break, цикл продолжает работать.Он переходит к следующей
# итерации, пропуская код , который должен был выполняться.Когда переменная i принимает значение 3, Python выполняет
# инструкцию continue, а не выводит число 3

# Аналогичного результата можно достичь при помощи цикла while  и инструкции continue.

i = 1
while i <= 5:
    if i == 3:
        i += 1
        continue
    print(i)
    i += 1

print("\n")

"""Вложенные циклы"""
"""Вы можете различными способами комбинировать циклы. Например, можно поместить один цикл в другой , или создать цикл
внутри цикла внутри цикла.Нет никаких ограничений по количеству циклов, которые можно помещать внутрь других циклов,
хотя эти ограничения важны.Когда цикл находится внутри другого цикла, второй цикл является вложенным в первый.
В этом случае цикл, содержащий внутри другой цикл, называется внешним,а ввложенный цикл - внутренним.Когда у вас есть
вложенный цикл, ввнутренний цикл выполняет перебор своего итерируемого объекта один раз за итерацию внешнего цикла."""

for i in range(1, 3):
    print(i)
    for letter in ["a", "b", "c"]:
        print(letter)

print("\n")
# Вложенный цикл for будет перебирать список ["a", "b", "c"] столько раз, сколько раз выполняется внешний цикл - в нашем
# случае дважды.Если бы вы сделали так, чтобы внешний цикл выполняется три раза, то и внутренний цикл также перебирал бы
# свой список трижды.

"""Вы можете использовать циклы for для прибавления каждого числа из одного списка к каждому числу другого списка."""

list1 = [1, 2, 3, 4]
list2 = [5, 6, 7, 8]
added = []
for i in list1:
    for j in list2:
        added.append(i + j)

print(added)

# Первый цикл выполняет итерированние каждого целого числа в списке list1.Для каждого элемента в этом списке второй
# цикл перебирает каждое целое число в собственном итерируемом объекте, затем прибавляет его к числу из list1 и
# добавляет результат в список added.Во ввтором цикле forr я назвал переменную j, поскольку имя i уже было занято в
# первом цикле.

"""Вы можете вкладывать цикл for внутрь цикла while и наоборот."""

# while input("д или н") != "н":
#     for i in range(1, 6):
#         print(i)

# Программа будет выводить числа от 1 до 5 , пока пользователь не введет "н".

# Глава 9. Файлы

"""Пути к файлам всегда создаются с помощью встроенного модуля Python os module.Функция path этого модуля принимает
в качестве параметра каждую папку из пути к файлу и выстраивает вам правильный путь к файлу"""

os.path.join("C", "Project", "fail.txt")

"""Режим который вы передаете функции open , определяет действия, которые можно будет совершать с открываемым файлом.
'r' - открывает файл только для чтения
'w' - открывает файл только для записи.Удаляет содержимое файла,если файл существует.Если файл не существует создает
новый файл для записи
'w+' - открывает файл для чтения и для записи.Удаляет содержимое файла,если файл существует.Если файл не существует 
создает новый файл для чтения и записи
Функция open возвращает так называемый файловый объект, который используется для чтения и/или записи в ваш файл.Когда 
вы используйте режим 'w', функция open создает новый файл(если он не существует) в каталоге, 
где работает ваша программа.
Затем вы можете использовать метод write на фаловом объекте, чтобы осуществить запись в файл, и метод close, чтобы 
закрыть его.Закрывать файл нужно всегда после открытия, иначе это может вызвать проблемы с программой. """

fail = open("fail.txt", "w")
fail.write("Hello mr.paython")
fail.close()

"""Автоматическое закрытие файлов"""

"""Также существует более удобный способ открытия файла, с ним не нужно держать в памяти необходимость закрытия файла.
Нужно поместить весь код в синтаксис with - составной инстукции, автоматически выполняющей действие после того, как
Paython проходит ее.
Синтаксис для открытия следующий with open (путь_к_файлу, режим) as имя_переменной: ваш_код.Значение путь_к_файлу 
представляет путь к вашему файлу,затем указывается режим, в которм нужно окрыть файл('r','w','w+'), имя_переменной,
которой назначен файловый объект, а значение ваш_код обозначает код, у которого есть доступ к этой переменной."""
with open("st.txt", "w") as f:
    f.write("Hello penis lebovski.I am Python")

"""Чтение из файлов"""

"""Если надо прочесть то передаете 'r' в качестве второго параметра в open. Затем вы вызываете метод read в своем 
файловом объекте, что возращает итерируемый объект со всеми строками файла."""

with open("st.txt", "r") as f:
    print(f.read())

"""Вызвать read, не закрывая и не открывая файл заново, можно лишь один раз, так что если вам понадобится содержимое
файла похже , вы должны сохранить его в переменной или контейнере."""

mylist = []
with open("st.txt", "r") as f:
    mylist.append(f.read())

print(mylist)

"""Теперь позже в программе вы сможете получить доступ к этим данным"""

"""CSV-файлы"""
"""CSV-файл: файл с расширением .csv, внутри которого данные разделяются с помощью запятых(CSV расшифровыется как
Comma Separated Values - значения, разделенные запятыми).Часто используется в программах наподобие Excel, обрабатывающих
электронные таблицы"""
"""CSV-файл можно открывать с помощью инстукции with, но внутри нее нужно использовать модуль csv, чтобы конвертировать
файловый объект в объект CSV. У моддуля csv  есть метод writer, который принимает файловый объект и разделитель.
Метод writer возвращает объект csv с помощью метода writerow.Метод writerow принимает в качестве параметра список,
и вы мможете его использовать для записи в CSV-файл. Каждый элемент в списке записывается - отделенный разделителем,
который вы передали методу writer - в строку в CSV-файле. Метод writerow создает только одну строку, так что для 
создания двух строк его нужно вызывать дважды"""

with open("st.csv", "w") as f:
    w = csv.writer(f, delimiter=",")
    w.writerow(["один", "два", "три"])
    w.writerow(["четрыре", "пять", "шесть"])

"""Так же можно использовать для чтения содержимого файла.Чтобы выполнить чтение из CSV-файла, сначало передайте 
значение 'r' в качестве второго параметра функции open, чтобы открыть файл для чтения. После этого внутри интсрукции
with вызовите метод reader, передав в него файловый объект и запятую в качестве разделителя - это вернет итерируемый
объект, с помощью которого можно получить доступ к каждой строке файла."""

with open("st.csv", "r") as f:
    r = csv.reader(f, delimiter=",")
    for row in r:
        print(",".join(row))


# Глава 10. Практикум
# Игра Виселица

def hangman(word):
    wrong = 0
    stages = ["",
              "_______         ",
              "|               ",
              "|      |        ",
              "|      0        ",
              "|     /|\       ",
              "|     / \       ",
              "                "
              ]
    rletters = list(word)
    board = ["__"] * len(word)
    win = False
    print("Добро пожаловать на казнь")
    while wrong < len(stages) - 1:
        print("\n")
        msg = "Введите букву: "
        char = input(msg)
        if char in rletters:
            cind = rletters.index(char)
            board[cind] = char
            rletters[cind] = "$"
        else:
            wrong += 1
        print((" ".join(board)))
        e = wrong + 1
        print("\n".join(stages[0:e]))
        if "__" not in board:
            print("Вы выйграли! Было загадано слово :")
            print(" ".join(board))
            win = True
            break
    if not win:
        print("\n".join(stages[0:wrong]))
        print(f"Вы проиграли, было загадано слово {word}")


hangman("лысый")
